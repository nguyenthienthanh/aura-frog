{
  "hooks": {
    "SessionStart": [
      {
        "hooks": [
          {
            "type": "prompt",
            "prompt": "üê∏ Aura Frog v1.2.6 is active - A Claude Code Plugin\n\n**Available Commands:**\n- workflow:start <task> - Start 9-phase TDD workflow\n- bugfix:quick <description> - Quick bug fix\n- project:init - Initialize project context\n- agent:list - Show all available agents\n\n**Skills System:** 26+ auto-invoking skills active (agent-detector, workflow-orchestrator, project-context-loader, bugfix-quick, test-writer, code-reviewer, jira-integration, figma-integration, confluence-integration, session-continuation, lazy-agent-loader, response-analyzer, state-persistence)\n\nType any command or use natural language - Skills will auto-activate based on your intent."
          }
        ]
      }
    ],
    "PreToolUse": [
      {
        "matcher": "Bash",
        "hooks": [
          {
            "type": "command",
            "comment": "Block dangerous destructive commands",
            "command": "if echo \"$CLAUDE_TOOL_INPUT\" | grep -qE '(rm -rf /|mkfs|dd if=|:(){|fork|shutdown|reboot|halt)'; then echo '‚ö†Ô∏è Blocked: Potentially destructive command detected' >&2; exit 2; fi"
          }
        ]
      },
      {
        "matcher": "Write|Edit",
        "hooks": [
          {
            "type": "command",
            "comment": "Remind to load project context before code generation",
            "command": "if [ ! -f .claude/project-contexts/*/project-config.yaml ]; then echo 'üí° Reminder: Run project:init to create project context before generating code' >&2; fi"
          },
          {
            "type": "command",
            "comment": "Block writing secrets to tracked files (.env, credentials, tokens)",
            "command": "if echo \"$CLAUDE_FILE_PATHS\" | grep -qE '(\\.env$|\\.env\\.|credentials|secrets|tokens\\.json|api[_-]?keys)'; then if git ls-files --error-unmatch \"$CLAUDE_FILE_PATHS\" 2>/dev/null; then echo 'üîí Warning: This file may contain secrets and is tracked by git. Consider adding to .gitignore' >&2; fi; fi"
          },
          {
            "type": "command",
            "comment": "SAST: Warn about common security anti-patterns",
            "command": "if echo \"$CLAUDE_TOOL_INPUT\" | grep -qiE '(eval\\(|innerHTML\\s*=|dangerouslySetInnerHTML|exec\\(|password\\s*=\\s*[\"'\\'']\"|api[_-]?key\\s*=\\s*[\"'\\'']\")'; then echo 'üîê Security: Potential security concern detected. Review OWASP guidelines in rules/sast-security-scanning.md' >&2; fi"
          }
        ]
      }
    ],
    "PostToolUse": [
      {
        "matcher": "Bash",
        "hooks": [
          {
            "type": "command",
            "comment": "Log command execution for workflow tracking",
            "command": "if [ -d .claude/logs/workflows ]; then echo \"[$(date '+%Y-%m-%d %H:%M:%S')] Bash: $CLAUDE_TOOL_INPUT\" >> .claude/logs/workflows/commands.log; fi"
          }
        ]
      },
      {
        "matcher": "Read",
        "hooks": [
          {
            "type": "command",
            "comment": "Warn when reading large files that may consume significant context",
            "command": "if [ -n \"$CLAUDE_FILE_PATHS\" ] && [ -f \"$CLAUDE_FILE_PATHS\" ]; then FILE_LINES=$(wc -l < \"$CLAUDE_FILE_PATHS\" 2>/dev/null || echo 0); if [ \"$FILE_LINES\" -gt 500 ]; then echo \"üìÑ Large file ($FILE_LINES lines). Consider using response-analyzer skill for chunked reading.\" >&2; fi; fi"
          }
        ]
      }
    ],
    "UserPromptSubmit": [
      {
        "hooks": [
          {
            "type": "command",
            "comment": "Detect JIRA ticket IDs and suggest jira-integration skill",
            "command": "if echo \"$CLAUDE_USER_INPUT\" | grep -qE '[A-Z]{2,10}-[0-9]+'; then echo 'üé´ JIRA ticket detected - jira-integration skill may auto-activate' >&2; fi"
          },
          {
            "type": "command",
            "comment": "Detect Figma URLs and suggest figma-integration skill",
            "command": "if echo \"$CLAUDE_USER_INPUT\" | grep -q 'figma.com/file'; then echo 'üé® Figma link detected - figma-integration skill may auto-activate' >&2; fi"
          },
          {
            "type": "command",
            "comment": "Detect Confluence URLs and suggest confluence-integration skill",
            "command": "if echo \"$CLAUDE_USER_INPUT\" | grep -qE 'atlassian.net/wiki|confluence'; then echo 'üìö Confluence link detected - confluence-integration skill may auto-activate' >&2; fi"
          },
          {
            "type": "command",
            "comment": "Detect GitHub PR/Issue URLs",
            "command": "if echo \"$CLAUDE_USER_INPUT\" | grep -qE 'github.com/.*/pull/[0-9]+|github.com/.*/issues/[0-9]+'; then echo 'üîó GitHub PR/Issue detected' >&2; fi"
          }
        ]
      }
    ],
    "SessionEnd": [
      {
        "hooks": [
          {
            "type": "command",
            "comment": "Suggest workflow handoff if active workflow exists",
            "command": "if [ -f .claude/logs/workflows/active-workflow.json ]; then echo 'üíæ Active workflow detected. Use workflow:handoff to save state for next session.' >&2; fi"
          },
          {
            "type": "command",
            "comment": "Remind about uncommitted changes",
            "command": "if git status --porcelain 2>/dev/null | grep -q '^[MADRC]'; then echo 'üìù You have uncommitted staged changes. Consider committing before ending session.' >&2; fi"
          }
        ]
      }
    ],
    "Stop": [
      {
        "hooks": [
          {
            "type": "command",
            "comment": "Play context-aware voiceover notification when Claude stops for approval",
            "command": "bash \"$HOME/.claude/plugins/marketplaces/aurafrog/aura-frog/hooks/stop-voice-notify.sh\" 2>&1 || true"
          }
        ]
      }
    ],
    "Notification": [
      {
        "hooks": [
          {
            "type": "command",
            "comment": "Play voiceover for critical notifications",
            "command": "PLUGIN_DIR=\"$HOME/.claude/plugins/marketplaces/aurafrog/aura-frog\"; if [ -f \"$PLUGIN_DIR/scripts/voice-notify.sh\" ] && echo \"$CLAUDE_NOTIFICATION\" | grep -qiE '(error|critical|failed)'; then bash \"$PLUGIN_DIR/scripts/voice-notify.sh\" 'Alert: Please check the notification' 'error' 2>&1 || true; fi"
          }
        ]
      }
    ]
  }
}
